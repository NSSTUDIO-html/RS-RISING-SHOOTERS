<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ROLLSROYCE.com</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.js"></script>
  <script>
    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
scene.background = new THREE.Color( 0xAAAAAA ); // Hexadecimal color (gray in this case)

    // Plane
    const planeGeometry = new THREE.PlaneGeometry(20, 20);
    const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -2;
    plane.receiveShadow = true;
    scene.add(plane);
const textureLoader53 = new THREE.TextureLoader();
    const metalnessMap2 = textureLoader53.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdN_0FmrQiJUD33tP1M5HBiiSeGCdHT5yApWgtr8idiDTPWaWXLy6TN_CV&s=10');
const roughnessMap2 = textureLoader53.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdN_0FmrQiJUD33tP1M5HBiiSeGCdHT5yApWgtr8idiDTPWaWXLy6TN_CV&s=10');
  const texture33 = textureLoader53.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR2ZoxrS4GI9Wib3BYcUs-aO9RgthnGdSW1D2inUGMhk5Hn0sRbECeIsLFm&s=10');
  const racer = new THREE.Group();
    // First torus
  const geometry1 = new THREE.TorusGeometry(2, 0.5, 8, 20);
  const geometry33 = new THREE.TorusGeometry(2, 0.7, 5, 20);
  
  const textureLoader3 = new THREE.TextureLoader();
  const texture = textureLoader3.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTWOdVUsyCJjgNQDtUHNrQ-UCwOFJ_2ameO7lLxDY5SbvK7UPvG7KIiBB4&s=10');
  const material1 = new THREE.MeshStandardMaterial({ map:texture,metalnessMap:metalnessMap2,emissive:0x000000});
    const torus1 = new THREE.Mesh(geometry1, material1);
    torus1.position.set(-5, 0, -3);
  torus1.scale.set(0.6,0.6,1.4);
    torus1.castShadow = true;
    racer.add(torus1);
  const texture334 = textureLoader53.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTHhu-Qy0ISXTgUAYS2Lx_EOgNZjwUk859MKSQts1xBicQlV-JsaTTTIUU&s=10');
  const material112 = new THREE.MeshStandardMaterial( { map:texture334,  metalnessMap:metalnessMap2,roughnessMap:roughnessMap2} );

  const torus3 = new THREE.Mesh(geometry1, material1);
    torus3.position.set(5, 0, -3);
  torus3.scale.set(0.6,0.6,1.4);
    torus3.castShadow = true;
    racer.add(torus3);
  const cylinderGeometry11 = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
  
  

    // Second torus
  const geometry2 = new THREE.TorusGeometry(2, 0.5,60, 20);
  const material2 = new THREE.MeshStandardMaterial({ map:texture});
    const torus2 = new THREE.Mesh(geometry2, material2);
    torus2.position.set(-5, 0, 3);
  torus2.scale.set(0.6,0.6,1.4);
    torus2.castShadow = true;
    racer.add(torus2);
  const torus5 = new THREE.Mesh(geometry2, material2);
    torus5.position.set(5, 0, 3);
  torus5.scale.set(0.6,0.6,1.4);
  torus5.rotation.set(Math.PI,Math.PI,Math.PI/2);
    torus5.castShadow = true;
    racer.add(torus5);
  const seatGeometry = new THREE.BoxGeometry(2.5, 1, 1);
  const texture123 = textureLoader3.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTR5zHtTz4Js2fBww03sKZNwflM5PG-Jq9Psx_sOJ3nf1WI4hUWJQS_Foc&s=10');
   const texture12 = textureLoader3.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKLCtE4LvxFHn9GtgjXAtfWWFcH13NsTJLC9Bq0qjl0_mclYwqhSWj9J5V&s=10');
   const seatMaterial = new THREE.MeshStandardMaterial({ map:texture123,metalnessMap:texture123,roughnessMap:texture123});
   const seatMaterial1 = new THREE.MeshStandardMaterial({ color:0x000000,metalnessMap:metalnessMap2,roughnessMap:roughnessMap2});
   const seatMaterial2 = new THREE.MeshStandardMaterial({ map:texture12,metalnessMap:texture123,roughnessMap:texture123});
   
  const carbase = new THREE.Mesh(seatGeometry, seatMaterial);
    carbase.position.set(0, 1, 0);
  carbase.scale.set(1,13,6.6);
  carbase.rotation.set(0,0,Math.PI/2);
    carbase.castShadow = true;
    racer.add(carbase);
  
  const carbase1 = new THREE.Mesh(seatGeometry, seatMaterial);
    carbase1.position.set(2, 3, 0);
  carbase1.scale.set(1,4,6);
  carbase1.rotation.set(0,0,Math.PI/2);
    carbase1.castShadow = true;
    racer.add(carbase1);
  const c1 = new THREE.Mesh(seatGeometry, seatMaterial1);
    c1.position.set(2, 3, 0);
  c1.scale.set(0.8,4,6.2);
  c1.rotation.set(0,0,Math.PI/2);
    c1.castShadow = true;
    racer.add(c1);
  const carbase2 = new THREE.Mesh(seatGeometry, seatMaterial1);
    carbase2.position.set(-1, 2.2, 0);
  carbase2.scale.set(0.6,4.4,5.9);
  carbase2.rotation.set(0,0,-Math.PI/4);
    carbase2.castShadow = true;
    racer.add(carbase2);
  const carbase3 = new THREE.Mesh(seatGeometry, seatMaterial1);
    carbase3.position.set(4.5,2, 0);
  carbase3.scale.set(0.6,4.4,5.9);
  carbase3.rotation.set(0,0,Math.PI/6);
    carbase3.castShadow = true;
    racer.add(carbase3);
  //car front face
  const c3 = new THREE.Mesh(seatGeometry, seatMaterial2);
    c3.position.set(-6.5,1, 0);
  c3.scale.set(0.3,3,3.5);
  c3.rotation.set(0,0,Math.PI);
    c3.castShadow = true;
    racer.add(c3);
  const hc3 = new THREE.Mesh(seatGeometry, seatMaterial2);
    hc3.position.set(-6.5,1.5, 2.5);
  hc3.scale.set(0.2,0.8,1.2);
  hc3.rotation.set(0,0,Math.PI);
    hc3.castShadow = true;
    racer.add(hc3);
  const hc4 = new THREE.Mesh(seatGeometry, seatMaterial2);
    hc4.position.set(-6.5,1.5, -2.5);
  hc4.scale.set(0.2,0.8,1.2);
  hc4.rotation.set(0,0,Math.PI);
    hc4.castShadow = true;
    racer.add(hc4);
  const c4 = new THREE.Mesh(seatGeometry, seatMaterial);
    c4.position.set(-4,1, 0);
  c4.scale.set(1.7,3,3.5);
  c4.rotation.set(0,0,Math.PI);
    c4.castShadow = true;
    racer.add(c4);
  const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
  const textureLoader = new THREE.TextureLoader();
    const texture11 = textureLoader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR2ZoxrS4GI9Wib3BYcUs-aO9RgthnGdSW1D2inUGMhk5Hn0sRbECeIsLFm&s=10');
  const cylinderMaterial = new THREE.MeshStandardMaterial({ map: texture11 });
    
  const c7 = new THREE.Mesh(cylinderGeometry, seatMaterial);
  c7.position.set(0,2,3);
  c7.scale.set(1,6.4,1);
  c7.rotation.set(Math.PI,Math.PI,Math.PI/2);
  c7.castShadow = true;
  racer.add(c7);
  const c8 = new THREE.Mesh(cylinderGeometry, seatMaterial);
  c8.position.set(0,2,-3);
  c8.scale.set(1,6.4,1);
  c8.rotation.set(Math.PI,Math.PI,Math.PI/2);
  c8.castShadow = true;
  racer.add(c8);
  const c9 = new THREE.Mesh(cylinderGeometry, seatMaterial);
  c9.position.set(6.5,1,0);
  c9.scale.set(1,3.2,3);
  c9.rotation.set(Math.PI/2,Math.PI,Math.PI);
  c9.castShadow = true;
  racer.add(c9);
  
  // Lighting
    const directionalLight = new THREE.DirectionalLight(0xffffff, 10);
    directionalLight.position.set(1, 2, 10);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    racer.add(ambientLight);
  racer.position.y += -0.5;
  scene.add(racer);

    // Camera setup
    camera.position.set(0, 0, 17);
    camera.lookAt(0, 0, 0);

    // Animation Variables
    const radius = 17; // Distance from the center
    let angleX = 0; // Starting X-axis angle
    let angleY = 0; // Starting Y-axis angle
    let swipeDirectionX = 0; // Controls rotation direction on X-axis based on swipe
    let swipeDirectionY = 0; // Controls rotation direction on Y-axis based on swipe

    // Touch Event Handlers
    let startX = 0, startY = 0;

    document.addEventListener("touchstart", (e) => {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
    });

    document.addEventListener("touchmove", (e) => {
      const endX = e.touches[0].clientX;
      const endY = e.touches[0].clientY;
      swipeDirectionX = endX - startX; // Calculate horizontal swipe for X-axis
      swipeDirectionY = endY - startY; // Calculate vertical swipe for Y-axis
    });

    document.addEventListener("touchend", () => {
      swipeDirectionX = 0; // Reset X-axis swipe direction
      swipeDirectionY = 0; // Reset Y-axis swipe direction
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      

      // Update the camera position based on swipe
      if (swipeDirectionX !== 0 || swipeDirectionY !== 0) {
        // Adjust the angles based on swipe direction
        angleX += swipeDirectionX * 0.001; // X-axis rotation
        angleY += swipeDirectionY * 0.001; // Y-axis rotation

        // Update camera position based on X and Y rotation
        camera.position.x = radius * Math.cos(angleY) * Math.cos(angleX); // X position
        camera.position.y = radius * Math.sin(angleY); // Y position (up/down)
        camera.position.z = radius * Math.cos(angleY) * Math.sin(angleX); // Z position (depth)

        // Make the camera look at the center
        camera.lookAt(0, 0, 0);
      }

      renderer.render(scene, camera);
    }

    animate();

    // Handle window resizing
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
